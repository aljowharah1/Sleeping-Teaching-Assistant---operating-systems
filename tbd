#include <stdio.h>
#include <stdlib.h>
#include <string.h> // memset
#include <pthread.h> // pthread_t, pthread_create, pthread_join
#include <semaphore.h> // sem_init, sem_wait, sem_post
#include <unistd.h> // sleep()
#include <time.h>

#define NUM_SEAT 3
#define SLEEP_MAX 5

// Semaphores
sem_t sem_stu;
sem_t sem_ta;

// Mutex
pthread_mutex_t mutex;

int chair[NUM_SEAT]; // Chairs for waiting students
int count = 0; // Number of waiting students
int next_seat = 0; // Index for the next seat
int next_teach = 0; // Index for the next student to be taught

void rand_sleep(void);
void* stu_programming(void* stu_id);
void* ta_teaching();

int main(int argc, char **argv) {
    pthread_t *students;
    pthread_t ta;
    int *student_ids;
    int student_num;
    int i;

    // Ask user for the number of students
    printf("How many students? ");
    scanf("%d", &student_num);

    if (student_num == 0) {
        printf("TA sleeping, no students!\n");
        exit(-1);
    }

    // Initialize
    students = (pthread_t*)malloc(sizeof(pthread_t) * student_num);
    student_ids = (int*)malloc(sizeof(int) * student_num);
    memset(chair, 0, sizeof(chair));

    sem_init(&sem_stu, 0, 0);
    sem_init(&sem_ta, 0, 1);
    pthread_mutex_init(&mutex, NULL);

    // Create TA thread
    pthread_create(&ta, NULL, ta_teaching, NULL);

    // Create student threads
    for (i = 0; i < student_num; i++) {
        student_ids[i] = i + 1;
        pthread_create(&students[i], NULL, stu_programming, (void*)&student_ids[i]);
    }

    // Wait for threads
    pthread_join(ta, NULL);
    for (i = 0; i < student_num; i++) {
        pthread_join(students[i], NULL);
    }

    // Free memory
    free(students);
    free(student_ids);

    return 0;
}

void* stu_programming(void* stu_id) {
    int id = *(int*)stu_id;

    printf("[stu] student %d is leaving for TA office\n", id);

    while (1) {
        rand_sleep();

        pthread_mutex_lock(&mutex);

        if (count < NUM_SEAT) {
            chair[next_seat] = id;
            count++;
            printf("	[stu] student %d is waiting seated at hallway\n", id);
            printf("waiting students : [1] %d [2] %d [3] %d\n", chair[0], chair[1], chair[2]);
            next_seat = (next_seat + 1) % NUM_SEAT;

            pthread_mutex_unlock(&mutex);

            sem_post(&sem_stu);  // Notify TA
            sem_wait(&sem_ta);   // Wait for TA to finish teaching
            break; // Exit loop after being taught
        } else {
            pthread_mutex_unlock(&mutex);
            printf("[stu] no more chairs. student %d is outside hallway and will be back later\n", id);
            rand_sleep(); // Simulate the student retrying later
        }
    }

    return NULL;
}

void* ta_teaching() {
    while (1) {
        pthread_mutex_lock(&mutex);

        // Check if the wait queue is empty
        if (count == 0) {
            printf("waiting students : [1] %d [2] %d [3] %d\n", chair[0], chair[1], chair[2]);
            printf("[ta] TA is sleeping as the wait queue is empty...\n");
            pthread_mutex_unlock(&mutex);

            sem_wait(&sem_stu); // Wait for a student to wake up the TA
            continue;
        }

        // TA helps the next student
        printf("		[ta] TA is teaching student %d\n", chair[next_teach]);
        chair[next_teach] = 0;  // Empty the chair
        count--;  // Decrease the number of waiting students

        printf("waiting students : [1] %d [2] %d [3] %d\n", chair[0], chair[1], chair[2]);
        next_teach = (next_teach + 1) % NUM_SEAT;

        pthread_mutex_unlock(&mutex);

        rand_sleep();  // Simulate teaching time

        printf("		[ta] Teaching finished.\n");
    }
}

void rand_sleep(void) {
    int time = rand() % SLEEP_MAX + 1;
    sleep(time);
}
